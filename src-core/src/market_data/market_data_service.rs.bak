use async_trait::async_trait;
use chrono::{DateTime, Duration, Local, NaiveDate, NaiveDateTime, TimeZone, Utc};
use log::{debug, error};
use rust_decimal::Decimal;
use std::collections::{HashMap, HashSet};
use std::sync::Arc;
use std::time::SystemTime;
use tokio::sync::RwLock;

use super::market_data_constants::*;
use super::market_data_model::{
    LatestQuotePair, MarketDataProviderInfo, MarketDataProviderSetting, Quote, QuoteRequest,
    QuoteSummary, UpdateMarketDataProviderSetting, QuoteImport, ImportValidationStatus,
};
use super::market_data_traits::{MarketDataRepositoryTrait, MarketDataServiceTrait};
use super::providers::models::AssetProfile;
use crate::assets::assets_constants::CASH_ASSET_TYPE;
use crate::assets::assets_traits::AssetRepositoryTrait;
use crate::errors::Result;
use crate::market_data::providers::ProviderRegistry;
use crate::utils::time_utils;
use crate::settings::SettingsServiceTrait;

const QUOTE_LOOKBACK_DAYS: i64 = 7;

pub struct MarketDataService {
    settings_service: Option<Arc<dyn SettingsServiceTrait>>,
    provider_registry: Arc<RwLock<ProviderRegistry>>,
    repository: Arc<dyn MarketDataRepositoryTrait + Send + Sync>,
    asset_repository: Arc<dyn AssetRepositoryTrait + Send + Sync>,
}

#[async_trait]
impl MarketDataServiceTrait for MarketDataService {
    async fn search_symbol(&self, query: &str) -> Result<Vec<QuoteSummary>> {
        self.provider_registry
            .read()
            .await
            .search_ticker(query)
            .await
            .map_err(|e| {
                error!("Failed to search symbol '{}': {}", query, e);
                e.into()
            })
    }

    async fn get_latest_quote(
        &self,
        symbol: &str,
        currency: &str,
    ) -> Result<Option<Quote>> {
        let quote_request = QuoteRequest {
            symbol: symbol.to_string(),
            currency: currency.to_string(),
        };

        self.get_latest_quotes_bulk(&[quote_request])
            .await
            .map(|quotes| quotes.into_iter().next())
    }

    async fn get_latest_quotes_bulk(
        &self,
        quote_requests: &[QuoteRequest],
    ) -> Result<Vec<Quote>> {
        let mut results = Vec::new();
        let mut failed_requests = Vec::new();

        // Group requests by provider for efficiency
        let mut provider_requests: HashMap<String, Vec<QuoteRequest>> = HashMap::new();

        for request in quote_requests {
            let provider = self
                .provider_registry
                .read()
                .await
                .get_provider_for_symbol(&request.symbol)
                .await;

            match provider {
                Some(provider_name) => {
                    provider_requests
                        .entry(provider_name.to_string())
                        .or_default()
                        .push(request.clone());
                }
                None => {
                    error!("No provider found for symbol: {}", request.symbol);
                    failed_requests.push(request.clone());
                }
            }
        }

        // Process requests for each provider
        for (provider_name, requests) in provider_requests {
            let provider = self.provider_registry.read().await.get_provider(&provider_name).await;
            
            if let Some(provider) = provider {
                let start = SystemTime::now() - Duration::days(QUOTE_LOOKBACK_DAYS);
                let end = SystemTime::now();

                let symbols_with_currencies: Vec<(String, String, Option<String>)> = requests
                    .iter()
                    .map(|req| (req.symbol.clone(), req.currency.clone(), None))
                    .collect();

                match provider
                    .get_historical_quotes_bulk(&symbols_with_currencies, start, end)
                    .await
                {
                    Ok((quotes, failed_symbols)) => {
                        // Get the latest quote for each symbol
                        let mut latest_quotes: HashMap<String, Quote> = HashMap::new();
                        
                        for quote in quotes {
                            let entry = latest_quotes.entry(quote.symbol.clone());
                            entry
                                .and_modify(|existing| {
                                    if quote.timestamp > existing.timestamp {
                                        *existing = quote.clone();
                                    }
                                })
                                .or_insert(quote);
                        }

                        results.extend(latest_quotes.into_values());
                        failed_requests.extend(
                            failed_symbols
                                .into_iter()
                                .zip(requests.iter())
                                .map(|((symbol, currency, _), req)| QuoteRequest {
                                    symbol,
                                    currency,
                                })
                        );
                    }
                    Err(e) => {
                        error!(
                            "Failed to get quotes from provider '{}': {}",
                            provider_name, e
                        );
                        failed_requests.extend(requests.clone());
                    }
                }
            }
        }

        if failed_requests.is_empty() {
            Ok(results)
        } else {
            Err(crate::errors::Error::MarketData(
                crate::market_data::MarketDataError::ProviderError(format!(
                    "Failed to fetch {} quotes",
                    failed_requests.len()
                )),
            ))
        }
    }

    async fn get_historical_quotes(
        &self,
        symbol: &str,
        start: SystemTime,
        end: SystemTime,
        currency: &str,
    ) -> Result<Vec<Quote>> {
        let provider = self
            .provider_registry
            .read()
            .await
            .get_provider_for_symbol(symbol)
            .await;

        match provider {
            Some(provider_name) => {
                let provider = self
                    .provider_registry
                    .read()
                    .await
                    .get_provider(provider_name)
                    .await;

                if let Some(provider) = provider {
                    provider
                        .get_historical_quotes(symbol, start, end, currency.to_string())
                        .await
                        .map_err(|e| {
                            error!(
                                "Failed to get historical quotes for '{}' from provider '{}': {}",
                                symbol, provider_name, e
                            );
                            e.into()
                        })
                } else {
                    Err(crate::errors::Error::MarketData(
                        crate::market_data::MarketDataError::NotFound(symbol.to_string()),
                    ))
                }
            }
            None => Err(crate::errors::Error::MarketData(
                crate::market_data::MarketDataError::NotFound(symbol.to_string()),
            )),
        }
    }

    async fn get_asset_profile(&self, symbol: &str) -> Result<Option<AssetProfile>> {
        let provider = self
            .provider_registry
            .read()
            .await
            .get_provider_for_symbol(symbol)
            .await;

        match provider {
            Some(provider_name) => {
                let provider = self
                    .provider_registry
                    .read()
                    .await
                    .get_provider(provider_name)
                    .await;

                if let Some(provider) = provider {
                    match provider.get_asset_profile(symbol).await {
                        Ok(profile) => Ok(Some(profile)),
                        Err(crate::market_data::MarketDataError::NotFound(_)) => Ok(None),
                        Err(e) => {
                            error!(
                                "Failed to get asset profile for '{}' from provider '{}': {}",
                                symbol, provider_name, e
                            );
                            Err(e.into())
                        }
                    }
                } else {
                    Ok(None)
                }
            }
            None => Ok(None),
        }
    }

    async fn import_quotes(&self, quotes: Vec<QuoteImport>) -> Result<Vec<ImportValidationStatus>> {
        let mut validation_results = Vec::new();

        for quote_import in quotes {
            let validation_status = self.validate_quote_import(&quote_import).await;
            validation_results.push(validation_status);
        }

        let valid_quotes: Vec<Quote> = validation_results
            .iter()
            .zip(quotes.iter())
            .filter_map(|(status, import)| match status {
                ImportValidationStatus::Valid => {
                    let quote = Quote {
                        id: format!("{}_{}", import.symbol, import.timestamp.format("%Y%m%d")),
                        symbol: import.symbol.clone(),
                        timestamp: import.timestamp,
                        open: import.open,
                        high: import.high,
                        low: import.low,
                        close: import.close,
                        adjclose: import.close,
                        volume: import.volume,
                        currency: import.currency.clone(),
                        data_source: crate::market_data::market_data_model::DataSource::Manual,
                        created_at: Utc::now(),
                    };
                    Some(quote)
                }
                _ => None,
            })
            .collect();

        if !valid_quotes.is_empty() {
            self.repository.save_quotes_bulk(&valid_quotes).await?;
        }

        Ok(validation_results)
    }

    async fn validate_quote_import(&self, quote_import: &QuoteImport) -> ImportValidationStatus {
        // Validate symbol exists
        let asset = self
            .asset_repository
            .get_asset_by_symbol(&quote_import.symbol)
            .await;

        if asset.is_err() {
            return ImportValidationStatus::InvalidSymbol(format!(
                "Asset '{}' not found",
                quote_import.symbol
            ));
        }

        // Validate price data
        if quote_import.open.is_sign_negative()
            || quote_import.high.is_sign_negative()
            || quote_import.low.is_sign_negative()
            || quote_import.close.is_sign_negative()
        {
            return ImportValidationStatus::InvalidPrice(
                "Prices cannot be negative".to_string(),
            );
        }

        // Validate price relationships
        if quote_import.high < quote_import.open
            || quote_import.high < quote_import.close
            || quote_import.high < quote_import.low
        {
            return ImportValidationStatus::InvalidPrice(
                "High price must be >= other prices".to_string(),
            );
        }

        if quote_import.low > quote_import.open
            || quote_import.low > quote_import.close
            || quote_import.low > quote_import.high
        {
            return ImportValidationStatus::InvalidPrice(
                "Low price must be <= other prices".to_string(),
            );
        }

        // Validate volume
        if quote_import.volume.is_sign_negative() {
            return ImportValidationStatus::InvalidVolume(
                "Volume cannot be negative".to_string(),
            );
        }

        ImportValidationStatus::Valid
    }

    async fn get_provider_settings(&self) -> Result<Vec<MarketDataProviderSetting>> {
        let providers = self.provider_registry.read().await.get_all_providers().await;
        let mut settings = Vec::new();

        for provider in providers {
            let setting = MarketDataProviderSetting {
                name: provider.name().to_string(),
                priority: provider.priority(),
                enabled: true,
                api_key: None,
                base_url: None,
            };
            settings.push(setting);
        }

        Ok(settings)
    }

    async fn update_provider_setting(
        &self,
        update: UpdateMarketDataProviderSetting,
    ) -> Result<()> {
        // This would typically update settings in a database
        // For now, we'll just log the update
        debug!(
            "Updating provider setting: {} -> enabled: {}",
            update.provider_name, update.enabled
        );
        Ok(())
    }

    async fn get_provider_info(&self) -> Result<Vec<MarketDataProviderInfo>> {
        let providers = self.provider_registry.read().await.get_all_providers().await;
        let mut info = Vec::new();

        for provider in providers {
            let provider_info = MarketDataProviderInfo {
                name: provider.name().to_string(),
                priority: provider.priority(),
                enabled: true,
                supported_assets: vec!["Stocks".to_string(), "ETFs".to_string(), "Funds".to_string()],
                supported_regions: vec!["Vietnam".to_string()],
            };
            info.push(provider_info);
        }

        Ok(info)
    }
}

impl MarketDataService {
    pub fn new(
        settings_service: Option<Arc<dyn SettingsServiceTrait>>,
        provider_registry: Arc<RwLock<ProviderRegistry>>,
        repository: Arc<dyn MarketDataRepositoryTrait + Send + Sync>,
        asset_repository: Arc<dyn AssetRepositoryTrait + Send + Sync>,
    ) -> Self {
        Self {
            settings_service,
            provider_registry,
            repository,
            asset_repository,
        }
    }
}
