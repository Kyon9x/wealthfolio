use async_trait::async_trait;
use reqwest::Client;
use std::time::{SystemTime, Duration};
use std::sync::Arc;
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use tokio::sync::RwLock;
use backoff::{ExponentialBackoff, future::retry, Error as BackoffError};
use crate::market_data::{MarketDataError, Quote as ModelQuote, AssetProfiler, QuoteSummary};
use crate::market_data::providers::market_data_provider::MarketDataProvider;
use chrono::{Utc, NaiveDate, TimeZone};
use rust_decimal::Decimal;
use serde::Deserialize;
use crate::market_data::providers::models::AssetProfile;
use crate::market_data::market_data_model::DataSource;

pub const DEFAULT_BASE_URL: &str = "http://127.0.0.1:8765";
pub const DEFAULT_TIMEOUT_SECONDS: u64 = 30;
pub const DEFAULT_MAX_RETRIES: u32 = 3;
pub const CIRCUIT_BREAKER_THRESHOLD: u32 = 5;
pub const CIRCUIT_BREAKER_TIMEOUT_SECONDS: u64 = 60;

#[derive(Debug, Clone)]
pub struct VnMarketConfig {
    pub base_url: String,
    pub timeout: Duration,
    pub max_retries: u32,
    pub circuit_breaker_threshold: u32,
    pub circuit_breaker_timeout: Duration,
    pub health_check_interval: Duration,
}

impl Default for VnMarketConfig {
    fn default() -> Self {
        Self {
            base_url: DEFAULT_BASE_URL.to_string(),
            timeout: Duration::from_secs(DEFAULT_TIMEOUT_SECONDS),
            max_retries: DEFAULT_MAX_RETRIES,
            circuit_breaker_threshold: CIRCUIT_BREAKER_THRESHOLD,
            circuit_breaker_timeout: Duration::from_secs(CIRCUIT_BREAKER_TIMEOUT_SECONDS),
            health_check_interval: Duration::from_secs(30),
        }
    }
}

#[derive(Debug)]
struct CircuitBreakerState {
    is_open: AtomicBool,
    failure_count: AtomicU64,
    last_failure_time: AtomicU64,
}

impl CircuitBreakerState {
    fn new() -> Self {
        Self {
            is_open: AtomicBool::new(false),
            failure_count: AtomicU64::new(0),
            last_failure_time: AtomicU64::new(0),
        }
    }

    fn is_open(&self) -> bool {
        self.is_open.load(Ordering::Acquire)
    }

    fn record_success(&self) {
        self.failure_count.store(0, Ordering::Release);
        self.is_open.store(false, Ordering::Release);
    }

    fn record_failure(&self, threshold: u32, _timeout: Duration) {
        let count = self.failure_count.fetch_add(1, Ordering::AcqRel) + 1;
        let now = Utc::now().timestamp() as u64;
        self.last_failure_time.store(now, Ordering::Release);

        if count >= threshold as u64 {
            self.is_open.store(true, Ordering::Release);
            log::warn!("Circuit breaker opened after {} failures", count);
        }
    }

    fn should_allow_request(&self, timeout: Duration) -> bool {
        if !self.is_open() {
            return true;
        }

        let last_failure = self.last_failure_time.load(Ordering::Acquire);
        let now = Utc::now().timestamp() as u64;

        if now - last_failure > timeout.as_secs() {
            self.is_open.store(false, Ordering::Release);
            self.failure_count.store(0, Ordering::Release);
            log::info!("Circuit breaker closed after timeout");
            true
        } else {
            false
        }
    }
}

pub struct VnMarketProvider {
    config: VnMarketConfig,
    client: Client,
    circuit_breaker: Arc<CircuitBreakerState>,
    last_health_check: Arc<RwLock<SystemTime>>,
}

impl VnMarketProvider {
    pub fn new(config: VnMarketConfig) -> Self {
        let client = Client::builder()
            .timeout(config.timeout)
            .no_proxy()
            .build()
            .unwrap_or_else(|_| Client::new());

        VnMarketProvider {
            config,
            client,
            circuit_breaker: Arc::new(CircuitBreakerState::new()),
            last_health_check: Arc::new(RwLock::new(SystemTime::UNIX_EPOCH)),
        }
    }

    pub fn with_default_url() -> Self {
        Self::new(VnMarketConfig::default())
    }

    pub fn with_base_url(base_url: String) -> Self {
        let mut config = VnMarketConfig::default();
        config.base_url = base_url;
        Self::new(config)
    }

    /// Normalize symbol by stripping .VN suffix for VN Market Service API calls
    /// Example: "MBB.VN" -> "MBB", "FPT.VN" -> "FPT"
    fn normalize_symbol(symbol: &str) -> &str {
        symbol.strip_suffix(".VN").unwrap_or(symbol)
    }

    /// Check if service is healthy before making requests
    async fn check_health(&self) -> Result<(), MarketDataError> {
        let now = SystemTime::now();
        let last_check = *self.last_health_check.read().await;

        // Skip health check if we've checked recently
        if now.duration_since(last_check).unwrap_or(Duration::ZERO) < self.config.health_check_interval {
            return Ok(());
        }

        let url = format!("{}/health", self.config.base_url);

        let operation = || async {
            self.client
                .get(&url)
                .send()
                .await
                .map_err(|e| {
                    let error = MarketDataError::NetworkError(e);
                    if matches!(error, MarketDataError::NetworkError(_)) {
                        BackoffError::transient(error)
                    } else {
                        BackoffError::permanent(error)
                    }
                })
                .and_then(|response| {
                    if response.status().is_success() {
                        Ok(())
                    } else {
                        Err(BackoffError::transient(MarketDataError::ProviderError(
                            format!("Health check failed with status: {}", response.status())
                        )))
                    }
                })
        };

        let backoff = ExponentialBackoff {
            max_elapsed_time: Some(Duration::from_secs(10)),
            max_interval: Duration::from_secs(2),
            ..Default::default()
        };

        match retry(backoff, operation).await {
            Ok(_) => {
                *self.last_health_check.write().await = now;
                self.circuit_breaker.record_success();
                Ok(())
            }
            Err(e) => {
                self.circuit_breaker.record_failure(
                    self.config.circuit_breaker_threshold,
                    self.config.circuit_breaker_timeout
                );
                Err(e)
            }
        }
    }

    /// Execute HTTP request with retry logic and circuit breaker
    async fn execute_request<F, T>(&self, operation: F) -> Result<T, MarketDataError>
    where
        F: Fn() -> std::pin::Pin<Box<dyn std::future::Future<Output = Result<T, MarketDataError>> + Send>> + Send + Sync,
    {
        // Check circuit breaker first
        if !self.circuit_breaker.should_allow_request(self.config.circuit_breaker_timeout) {
            return Err(MarketDataError::ProviderError(
                "Circuit breaker is open - service temporarily unavailable".to_string()
            ));
        }

        // Perform health check
        if let Err(e) = self.check_health().await {
            return Err(e);
        }

        let retry_operation = || {
            let circuit_breaker = self.circuit_breaker.clone();
            let future = operation();
            Box::pin(async move {
                match future.await {
                    Ok(result) => {
                        circuit_breaker.record_success();
                        Ok(result)
                    }
                    Err(error) => {
                        let is_transient = match &error {
                            MarketDataError::NetworkError(_) => true,
                            MarketDataError::ProviderError(msg)
                                if msg.contains("timeout") || msg.contains("connection") => true,
                            MarketDataError::RateLimitExceeded => true,
                            _ => false,
                        };

                        if is_transient {
                            circuit_breaker.record_failure(
                                CIRCUIT_BREAKER_THRESHOLD,
                                Duration::from_secs(CIRCUIT_BREAKER_TIMEOUT_SECONDS)
                            );
                            Err(BackoffError::transient(error))
                        } else {
                            Err(BackoffError::permanent(error))
                        }
                    }
                }
            })
        };

        let backoff = ExponentialBackoff {
            max_elapsed_time: Some(self.config.timeout),
            max_interval: Duration::from_secs(5),
            ..Default::default()
        };

        retry(backoff, retry_operation).await
    }
}

#[derive(Debug, Deserialize)]
struct HistoryResponse {
    symbol: String,
    history: Vec<HistoryItem>,
    currency: String,
}

#[derive(Debug, Deserialize)]
struct HistoryItem {
    date: String,
    nav: f64,
    open: f64,
    high: f64,
    low: f64,
    close: f64,
    volume: f64,
}

#[derive(Debug, Deserialize)]
struct SearchResponse {
    symbol: String,
    fund_name: String,
    fund_type: Option<String>,
    management_company: Option<String>,
    inception_date: Option<String>,
    nav_per_unit: Option<f64>,
    currency: String,
}

#[derive(Debug, Deserialize)]
struct FundBasicInfo {
    symbol: String,
    fund_name: String,
    asset_type: String,
    data_source: String,
}

#[derive(Debug, Deserialize)]
struct FundListResponse {
    funds: Vec<FundBasicInfo>,
    total: usize,
}

#[derive(Debug, Deserialize)]
struct UnifiedSearchResponse {
    results: Vec<UnifiedSearchResult>,
    total: usize,
}

#[derive(Debug, Deserialize)]
struct UnifiedSearchResult {
    symbol: String,
    name: String,
    asset_type: String,
    exchange: String,
    currency: String,
    data_source: String,
}

#[async_trait]
impl MarketDataProvider for VnMarketProvider {
    fn name(&self) -> &'static str {
        "VN_MARKET"
    }

    fn priority(&self) -> u8 {
        1
    }

    async fn get_latest_quote(
        &self,
        symbol: &str,
        fallback_currency: String,
    ) -> Result<ModelQuote, MarketDataError> {
        let end = SystemTime::now();
        let start = end - std::time::Duration::from_secs(7 * 24 * 60 * 60);

        let quotes = self.get_historical_quotes(symbol, start, end, fallback_currency).await?;

        quotes
            .into_iter()
            .max_by_key(|q| q.timestamp)
            .ok_or_else(|| MarketDataError::NotFound(symbol.to_string()))
    }

    async fn get_historical_quotes(
        &self,
        symbol: &str,
        _start: SystemTime,
        _end: SystemTime,
        fallback_currency: String,
    ) -> Result<Vec<ModelQuote>, MarketDataError> {
        let normalized_symbol = Self::normalize_symbol(symbol);
        let url = format!("{}/history/{}", self.config.base_url, normalized_symbol);
        let symbol_clone = symbol.to_string();
        let fallback_currency_clone = fallback_currency.clone();
        let client = self.client.clone();

        self.execute_request(|| {
            let client = client.clone();
            let url = url.clone();
            let symbol_clone = symbol_clone.clone();
            let fallback_currency_clone = fallback_currency_clone.clone();
            Box::pin(async move {
            let response = client
                .get(&url)
                .send()
                .await
                .map_err(|e| MarketDataError::ProviderError(format!("VnMarket API error: {}", e)))?;

            if !response.status().is_success() {
                let error_body = response.text().await.unwrap_or_else(|_| "Unknown error".to_string());
                return Err(MarketDataError::ProviderError(format!("VnMarket API error: {}", error_body)));
            }

            let history_response: HistoryResponse = response
                .json()
                .await
                .map_err(|e| MarketDataError::ProviderError(format!("Failed to parse response: {}", e)))?;

            let currency = if history_response.currency.is_empty() {
                fallback_currency_clone
            } else {
                history_response.currency
            };

            let quotes: Vec<ModelQuote> = history_response
                .history
                .into_iter()
                .filter_map(|item| {
                    let date = NaiveDate::parse_from_str(&item.date, "%Y-%m-%d").ok()?;
                    let timestamp = Utc.from_utc_datetime(&date.and_hms_opt(0, 0, 0)?);

                    let nav = Decimal::from_f64_retain(item.nav).unwrap_or_default();
                    let open = Decimal::from_f64_retain(item.open).unwrap_or(nav);
                    let high = Decimal::from_f64_retain(item.high).unwrap_or(nav);
                    let low = Decimal::from_f64_retain(item.low).unwrap_or(nav);
                    let close = Decimal::from_f64_retain(item.close).unwrap_or(nav);
                    let volume = Decimal::from_f64_retain(item.volume).unwrap_or_default();

                    let id = format!("{}_{}", timestamp.format("%Y%m%d"), symbol_clone);

                    Some(ModelQuote {
                        id,
                        symbol: symbol_clone.clone(),
                        timestamp,
                        open,
                        high,
                        low,
                        close,
                        adjclose: close,
                        volume,
                        currency: currency.clone(),
                        data_source: DataSource::VnMarket,
                        created_at: Utc::now(),
                    })
                })
                .collect();

            if quotes.is_empty() {
                return Err(MarketDataError::NotFound(symbol_clone));
            }

            Ok(quotes)
            })
        }).await
    }

    async fn get_historical_quotes_bulk(
        &self,
        symbols_with_currencies: &[(String, String, Option<String>)],
        start: SystemTime,
        end: SystemTime,
    ) -> Result<(Vec<ModelQuote>, Vec<(String, String, Option<String>)>), MarketDataError> {
        let mut all_quotes = Vec::new();
        let mut failed_symbols = Vec::new();

        for (symbol, currency, data_source) in symbols_with_currencies {
            match self.get_historical_quotes(symbol, start, end, currency.clone()).await {
                Ok(mut quotes) => all_quotes.append(&mut quotes),
                Err(_) => failed_symbols.push((symbol.clone(), currency.clone(), data_source.clone())),
            }
        }

        Ok((all_quotes, failed_symbols))
    }
}

#[async_trait]
impl AssetProfiler for VnMarketProvider {
    async fn get_asset_profile(&self, symbol: &str) -> Result<AssetProfile, MarketDataError> {
        let normalized_symbol = Self::normalize_symbol(symbol);
        let url = format!("{}/search?query={}", self.config.base_url, normalized_symbol);
        let client = self.client.clone();
        self.execute_request(|| {
            let client = client.clone();
            let url = url.clone();
            Box::pin(async move {
                .send()
                .await
                .map_err(|e| MarketDataError::ProviderError(format!("VnMarket API error: {}", e)))?;

            if !response.status().is_success() {
                return Err(MarketDataError::NotFound(symbol.to_string()));
            }

            let search_response: UnifiedSearchResponse = response
                .json()
                .await
                .map_err(|e| MarketDataError::ProviderError(format!("Failed to parse response: {}", e)))?;

            // Get first result (should be exact match)
            let result = search_response.results.first()
                .ok_or_else(|| MarketDataError::NotFound(symbol.to_string()))?;

            // Map asset_type to appropriate asset class and asset_sub_class
            let (asset_class, asset_sub_class) = match result.asset_type.as_str() {
                "MUTUAL_FUND" => ("Equity", "MutualFund"),
                "STOCK" => ("Equity", "Stock"),
                "ETF" => ("Equity", "ETF"),
                "COMMODITY" => ("Commodity", "Commodity"),
                "INDEX" => ("Index", "Index"),
                _ => ("Unknown", "Unknown"),
            };

            Ok(AssetProfile {
                id: None,
                isin: None,
                symbol: result.symbol.clone(),
                symbol_mapping: None,
                name: Some(result.name.clone()),
                asset_type: Some(result.asset_type.clone()),
                asset_class: Some(asset_class.to_string()),
                asset_sub_class: Some(asset_sub_class.to_string()),
                currency: result.currency.clone(),
                data_source: "VN_MARKET".to_string(),
                notes: None,
                countries: None,
                categories: None,
                classes: None,
                attributes: None,
                sectors: None,
                url: None,
            })
        })).await
    }

    async fn search_ticker(&self, query: &str) -> Result<Vec<QuoteSummary>, MarketDataError> {
        // Only search if query ends with .VN or matches known Vietnamese patterns
        // This prevents conflicts with global symbols like GOLD, SILVER, etc.

        let query_upper = query.to_uppercase();

        // Blocklist of common global commodities/symbols to avoid conflicts
        // BUT allow VN-prefixed symbols like VN_GOLD, VN_OIL, etc. to pass through
        const GLOBAL_SYMBOLS: &[&str] = &["GOLD", "SILVER", "OIL", "GAS", "COPPER", "PLATINUM"];
        let is_vn_prefixed = query_upper.starts_with("VN_");
        if !is_vn_prefixed && GLOBAL_SYMBOLS.contains(&query_upper.as_str()) {
            return Ok(Vec::new());
        }

        let is_vn_suffix = query.ends_with(".VN") || query.ends_with(".vn");
        let is_vn_index = matches!(query_upper.as_str(), "VNINDEX" | "VN30" | "HNX" | "HNX30" | "UPCOM" | "VN" | "VNI");

        // For 3-5 char queries, only search if it contains digits or starts with VN/HN/UP
        // Most Vietnamese stocks are 3 chars like FPT, MBB, VNM
        // But exclude common commodities (unless VN-prefixed)
        let is_likely_vn_stock = query.len() >= 3 && query.len() <= 5 &&
                                 query.chars().all(|c| c.is_ascii_alphanumeric()) &&
                                 (query.starts_with("VN") ||
                                  query.starts_with("HN") ||
                                  query.starts_with("UP") ||
                                  query.chars().any(|c| c.is_ascii_digit()) ||
                                  query.len() == 3);  // Most VN stocks are exactly 3 chars

        // Allow VN-prefixed symbols (like VN_GOLD) to always search
        let should_search = is_vn_prefixed || is_vn_suffix || is_vn_index || is_likely_vn_stock;

        if !should_search {
            return Ok(Vec::new());
        }

        let url = format!("{}/search", self.config.base_url);
        let client = self.client.clone();
        let query_clone = query.to_string();

        self.execute_request(|| {
            let client = client.clone();
            let url = url.clone();
            let query_clone = query_clone.clone();
            Box::pin(async move {
                .await
                .map_err(|e| MarketDataError::ProviderError(format!("VnMarket API error: {}", e)))?;

            if !response.status().is_success() {
                return Ok(Vec::new());
            }

            let search_response: UnifiedSearchResponse = response
                .json()
                .await
                .map_err(|e| MarketDataError::ProviderError(format!("Failed to parse response: {}", e)))?;

            let query_lower = query_clone.to_lowercase();

            let mut results: Vec<QuoteSummary> = search_response
                .results
                .into_iter()
                .map(|result| {
                    let symbol_lower = result.symbol.to_lowercase();
                    let name_lower = result.name.to_lowercase();

                    let score = if symbol_lower == query_lower {
                        1.0
                    } else if symbol_lower.starts_with(&query_lower) {
                        0.9
                    } else if name_lower.contains(&query_lower) {
                        0.7
                    } else {
                        0.5
                    };

                    let (quote_type, type_display) = match result.asset_type.as_str() {
                        "FUND" => ("MUTUALFUND", "Mutual Fund"),
                        "STOCK" => ("EQUITY", "Stock"),
                        "INDEX" => ("INDEX", "Index"),
                        "COMMODITY" => ("COMMODITY", "Commodity"),
                        _ => ("OTHER", "Other"),
                    };

                    QuoteSummary {
                        symbol: result.symbol,
                        short_name: result.name.clone(),
                        long_name: result.name,
                        exchange: result.exchange,
                        quote_type: quote_type.to_string(),
                        type_display: type_display.to_string(),
                        index: "".to_string(),
                        score,
                        data_source: "VN_MARKET".to_string(),
                    }
                })
                .collect();

            results.sort_by(|a, b| b.score.partial_cmp(&a.score).unwrap_or(std::cmp::Ordering::Equal));
            results.truncate(10);

            Ok(results)
        })).await
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_normalize_symbol() {
        assert_eq!(VnMarketProvider::normalize_symbol("FPT.VN"), "FPT");
        assert_eq!(VnMarketProvider::normalize_symbol("MBB.VN"), "MBB");
        assert_eq!(VnMarketProvider::normalize_symbol("FPT"), "FPT");
        assert_eq!(VnMarketProvider::normalize_symbol("VNINDEX"), "VNINDEX");
    }

    #[test]
    fn test_circuit_breaker_state() {
        let state = CircuitBreakerState::new();

        assert!(!state.is_open());
        assert_eq!(state.failure_count.load(Ordering::Acquire), 0);

        // Record failures
        for _ in 0..3 {
            state.record_failure(5, Duration::from_secs(60));
        }
        assert!(!state.is_open());

        // Cross threshold
        state.record_failure(5, Duration::from_secs(60));
        assert!(state.is_open());

        // Record success should close it
        state.record_success();
        assert!(!state.is_open());
        assert_eq!(state.failure_count.load(Ordering::Acquire), 0);
    }

    #[test]
    fn test_config_default() {
        let config = VnMarketConfig::default();
        assert_eq!(config.base_url, DEFAULT_BASE_URL);
        assert_eq!(config.timeout, Duration::from_secs(DEFAULT_TIMEOUT_SECONDS));
        assert_eq!(config.max_retries, DEFAULT_MAX_RETRIES);
        assert_eq!(config.circuit_breaker_threshold, CIRCUIT_BREAKER_THRESHOLD);
        assert_eq!(config.circuit_breaker_timeout, Duration::from_secs(CIRCUIT_BREAKER_TIMEOUT_SECONDS));
    }
}
